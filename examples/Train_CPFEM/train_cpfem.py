#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Use data generated by micromechanical simulations to train ML yield function.
Please refer to DOI https://doi.org/10.5281/zenodo.10522337 for using, or citing the data associated with this work.

Authors: Ronak Shoghi, Alexander Hartmaier
ICAMS/Ruhr University Bochum, Germany.
January 2024

Published as part of pyLabFEA package under GNU GPL v3 license
"""
import pylabfea as FE
import numpy as np
import matplotlib.pyplot as plt
import pylabfea.training as CTD
from matplotlib.lines import Line2D
from scipy.optimize import fsolve
import matplotlib.lines as mlines
from matplotlib.gridspec import GridSpec
import random

def rgb_to_hex(rgb):
    return '#{:02x}{:02x}{:02x}'.format(int(rgb[0] * 255), int(rgb[1] * 255), 
                                        int(rgb[2] * 255))

def find_yloc(x, sunit, epl, mat):
    # Expand unit stresses 'sig' by factor 'x' and calculate yield function
    return mat.calc_yf(sunit * x, epl=epl)

# Import data from micromechanical simulations
db = FE.Data("Data_Random_Texture.json",
             epl_crit=2.e-3, epl_start=1.e-3, epl_max=0.03,
             depl=1.e-3,
             wh_data=True)
mat_ref = FE.Material(name="reference")  # define reference material
mat_ref.elasticity(CV=db.mat_data['elast_const'])
mat_ref.plasticity(sy=db.mat_data['sy_av'], khard=4.5e3)
mat_ref.calc_properties(verb=False, eps=0.02, sigeps=True)

print(f'Successfully imported data for {db.mat_data["Nlc"]} load cases')
mat_ml = FE.Material(db.mat_data['Name'], num=1)  # define material
mat_ml.from_data(db.mat_data)  # data-based definition of material

# Train SVC with data from all microstructures
mat_ml.train_SVC(C=4, gamma=0.5, Fe=0.7, Ce=0.9, Nseq=2, gridsearch=False, plot=False) # check the parameters with the values in the paper! # materials.py put a comment for Nseq= 1.
print(f'Training successful.\nNumber of support vectors: {len(mat_ml.svm_yf.support_vectors_)}')

# Testing
sig_tot, epl_tot, yf_ref = CTD.Create_Test_Sig(Json="Data_Random_Texture_Test.json")
yf_ml = mat_ml.calc_yf(sig_tot, epl_tot, pred=False)
Results = CTD.training_score(yf_ref, yf_ml)
print(Results)

#Plot Hardening levels over a meshed space
save_fig = False
ngrid = 100
scale_seq, pi_factor = mat_ml.scale_seq, np.pi
colors_hex = ['#550000', '#990000', '#bb0000', '#cc3333', '#ee3333', '#ff5050']
plastic_strains = [0, 0.005, 0.01, 0.015, 0.018, 0.025]
handles = []
xx, yy = np.meshgrid(np.linspace(-1, 1, ngrid), np.linspace(0, 2, ngrid))
yy, xx = yy * scale_seq, xx * pi_factor
Cart_hh = FE.sp_cart(np.c_[yy.ravel(), xx.ravel()])
Cart_hh_6D = np.hstack((Cart_hh, np.zeros((ngrid * ngrid, 3))))
grad_hh = mat_ml.calc_fgrad(Cart_hh_6D)
normalized_grad_hh = grad_hh / FE.eps_eq(grad_hh)[:, None]
fig = plt.figure(figsize=(6.7, 4))
fig.set_constrained_layout(True)
ax = fig.add_subplot(111, projection='polar')
for strain, color in zip(plastic_strains, colors_hex):
    Z = mat_ml.calc_yf(sig=Cart_hh_6D, epl=normalized_grad_hh * strain, pred=False)
    mat_ml.plot_data(Z, ax, xx, yy, c=color)
    handles.append(Line2D([], [], color=color, label=f'Equivalent Plastic Strain : {strain * 100:.1f}%'))
ax.legend(handles=handles, loc='upper left', bbox_to_anchor=(1.05, 1))
if save_fig:
    fig.savefig('Hardening_Levels.png', dpi=300)
plt.show()

# Plot initial yield locus in pi-plane with the average yield strength from data
Z = mat_ml.calc_yf(sig=Cart_hh_6D, epl=normalized_grad_hh * 0, pred=False)  # value of yield fct for every grid point
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(5.6, 4.5))
linet, = mat_ml.plot_data(Z, ax, xx, yy, c='black')
linet.set_linewidth(2.2)
lineu = ax.axhline(db.mat_data['sy_av'], color='#9A1414', lw=2)
legend_elements = [
    Line2D([0], [0], color='black', lw=2, label='ML'),
    Line2D([0], [0], color='#9A1414', lw=2, label='Data')
]
ax.set_xlabel(r'$\theta$ (rad)', fontsize=14)
ax.set_ylabel(r'$\sigma_{eq}$ (MPa)', fontsize=14)
ax.tick_params(axis='both', which='major', labelsize=12)
ax.legend(handles=legend_elements, loc='upper right', fontsize=12)
plt.tight_layout()
if save_fig:
    fig.savefig('Initial_Yield_Locus.png', dpi=300)
plt.show()

# Plot initial and final hardening level of trained ML yield function together with data points
peeq_dat = FE.eps_eq(db.mat_data['plastic_strain'])
ind0 =np.nonzero(np.logical_and(peeq_dat > 0.00019, peeq_dat < 0.00021))[0]
sig_d0 = FE.s_cyl(db.mat_data['flow_stress'][ind0, :], mat_ml)
ind1 = np.nonzero(np.logical_and(peeq_dat > 0.0249, peeq_dat < 0.0251))[0] #0.0248, 0.0252
sig_d1 = FE.s_cyl(db.mat_data['flow_stress'][ind1, :], mat_ml)
ngrid = 100
scale_seq, pi_factor = mat_ml.scale_seq, np.pi
xx, yy = np.meshgrid(np.linspace(-1, 1, ngrid), np.linspace(0, 2, ngrid))
yy, xx = yy * scale_seq, xx * pi_factor
Cart_hh = FE.sp_cart(np.c_[yy.ravel(), xx.ravel()])
Cart_hh_6D = np.hstack((Cart_hh, np.zeros((ngrid**2, 3))))
grad_hh = mat_ml.calc_fgrad(Cart_hh_6D)
normalized_grad_hh = grad_hh / FE.eps_eq(grad_hh)[:, None]
fig = plt.figure(figsize=(6.7, 4))
fig.set_constrained_layout(True)
ax = fig.add_subplot(111, projection='polar')
Z0 = mat_ml.calc_yf(sig=Cart_hh_6D, epl=normalized_grad_hh * 0, pred=False)
Z1 = mat_ml.calc_yf(sig=Cart_hh_6D, epl=normalized_grad_hh * 0.025, pred=False)
mat_ml.plot_data(Z0, ax, xx, yy, c="#600000")
mat_ml.plot_data(Z1, ax, xx, yy, c="#ff5050")
plt.scatter(sig_d0[:, 1], sig_d0[:, 0], s=5, c="black")
plt.scatter(sig_d1[:, 1], sig_d1[:, 0], s=5, c="black")
handle1 = mlines.Line2D([], [], color="#550000", label='Equivalent Plastic Strain : 0%')
handle2 = mlines.Line2D([], [], color="#ff3333", label='Equivalent Plastic Strain : 2.5%')
ax.legend(handles=[handle1, handle2], loc='upper left', bbox_to_anchor=(1.05, 1))
if save_fig:
    fig.savefig('ML+ScatterData.png', dpi=300)
plt.show()

# Reconstruct Stress-Strain Curve
ilc = 0  # number of load case to be plotted keep this section.
offs = 0 if ilc==0 else 1
istart = db.mat_data['lc_indices'][ilc - 1] + offs
istop = db.mat_data['lc_indices'][ilc]
sig_dat = db.mat_data['flow_stress'][istart:istop, :] # filter below 0.02% strain
epl_dat = db.mat_data['plastic_strain'][istart:istop, :] # filter below 0.02% strain
epl_plt = FE.eps_eq(epl_dat)
valid_indices = epl_plt >= 0.002
# Update epl_dat and sig_dat based on the filter
epl_dat_filtered = epl_dat[valid_indices, :]
sig_dat_filtered = sig_dat[valid_indices, :]
epl_plt_filtered = FE.eps_eq(epl_dat_filtered)
# define unit stress in loading direction
sig0 = sig_dat_filtered[-1, :] / FE.sig_eq_j2(sig_dat_filtered[-1, :])
Nlc = len(epl_dat_filtered)
sig_ml = []
for i in range(Nlc):
    x1 = fsolve(find_yloc, mat_ml.sy, args=(sig0, epl_dat_filtered[i, :], mat_ml),
                xtol=1.e-5)
    sig_ml.append(sig0 * x1)
sig_ml = np.array(sig_ml)
fig = plt.figure(figsize=(5.6, 4.7))
plt.scatter(epl_plt_filtered, FE.sig_eq_j2(sig_dat_filtered), label="Data", s=9, color='black')
plt.scatter(epl_plt_filtered, FE.sig_eq_j2(sig_ml), label="ML", s=10, color='#d60404')
text_size = 12
plt.tick_params(axis='both', which='major', labelsize=12)
plt.xlabel(xlabel="Equivalent Plastic Strain (.)", fontsize=14)
plt.ylabel(ylabel="Equivalent Stress (MPa)", fontsize=14)
legend_font_size = 12
legend = plt.legend(fontsize=legend_font_size)
legend.legend_handles[0]._sizes = [50]
legend.legend_handles[1]._sizes = [50]
plt.tight_layout()
if save_fig:
    fig.savefig('Reconstructed_Stress_Strain_Curve.png', dpi=300)
plt.show()
